// ========== Exercise E: Collections-C SLL Library ==========
// 
// Let's now verify algorithms based on real-world data structure.
// In particular, in this exercise, we will explore some of the
// singly-linked list algorithms in the Collections-C library
// [https://github.com/srdja/Collections-C] for the C language.
//
// The Collections-C (dubbed cc for short) singly-linked list
// data structure is defined using a struct as follows:
// 
//   typedef struct snode_s {
//     void *data;
//     struct snode_s *next;
//   } SNode;
//
//   struct cc_slist_s {
//     size_t size;
//     SNode *head;
//     SNode *tail;
//     ...
//   };
//
// Here, SNode is the typical singly-linked list data structure,
// and slist_s is a wrapper around the entire linked list that also
// includes the pointer to the tail of the list and the overall size
// of the linked list.

// === DON'T EDIT THIS ===
//#region

@config manual_fold : true

// We have our usual sll and lseg predicates as usual.
// Note that unlike the sll and lseg predicates seen in previous
// exercises, we have an additional parameter delta, which denotes
// the list of pointer addresses comprising the linked list.
// As we will see, this is useful for verifying the get_node_at
// function, which returns the i-th node (i.e. address) of the list.

predicate sll(+x, alpha, delta) {
    // empty
    (x == null) * (alpha == nil) * (delta == nil);
    // non-empty
    (x -b> #v, #z) * sll(#z, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

predicate lseg(+x, +y, alpha, delta) {
  (x == y) * (alpha == nil) * (delta == nil);
  (x -b> #v, #z) * lseg(#z, y, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

// We also have the cc_sll_ht predicate, which is the wrapper
// for the cc_slist_s struct. 
// Note that in the non-empty case, we have the lseg predicate,
// which describes the entire list except the last node, and
// then we have the sll predicate, which describes the last node.

predicate nounfold cc_sll_ht(+x, h, t, alpha, delta) {
  // Full cc_slist_s object: length, head, tail
  (x -b> 0, h, t) *
  (alpha == []) * (delta == []) *
  (h == null) * (t == null);

  (x -b> #l, #h, #t) *
  (h == #h) * (t == #t) *
  lseg(#h, #t, #beta, #gamma) *
  sll(#t, [ #last ], [ #t ]) *
  (alpha == #beta @ [ #last ]) *
  (delta == #gamma @ [ #t ]) *
  (#l == (len #beta) + 1)
}

// Finally, we have a top-level predicate cc_sll that
// existentially quantfies the head and tail pointers.

predicate cc_sll(+x, alpha, delta) {
  cc_sll_ht(x, #h, #t, alpha, delta)
}

predicate list_nth(+vs, +i : Int, +v) {
  (i == 0) * (vs == v :: #vs) ;
  (i > 0) * (i == (#j + 1)) * (i < len(vs)) * (vs == #v :: #vs) * list_nth(#vs, #j, v)
}

predicate list_count(+vs, +k, n : Int) {
  (vs == []) * (n == 0);
  (vs == k :: #vss) * list_count(#vss, k, #m) * (n == #m + 1);
  (vs == #v :: #vss) * (#v != k) * list_count(#vss, k, n) 
}

lemma lseg_to_sll {
  statement:
    forall x, alpha.
      lseg(x, null, alpha, #delta) |- sll(x, alpha, #delta)
}

lemma concat_lseg_sll {
  statement:
    forall x, y, alpha, beta, delta, gamma.
      lseg(x, y, alpha, delta) * sll(y, beta, gamma) |- sll(x, alpha @ beta, delta @ gamma)

}

lemma sll_split_last {
  statement:
    forall x, alpha, last, delta, lastptr.
      sll(x, alpha@[last], delta@[lastptr]) |- lseg(x, lastptr, alpha, delta) * sll(lastptr, [last], [lastptr])
}

lemma lseg_append {
  statement:
    forall x, y, alpha, yval, ynext, delta.
      lseg(x, y, alpha, delta) * (y -b> yval, ynext) |- lseg(x, ynext, alpha @ [ yval ], delta @ [y])

}

lemma list_nth_next {
  statement:
    forall xs, ys, v, l, j.
    list_nth(xs @ [v, l] @ ys, j, v) |- list_nth(xs @ [v, l] @ ys, j + 1, l)
}

lemma list_count_create {
  statement:
    forall v, vs, xs, k.
      sll(v, vs, xs) |- sll(v, vs, xs) * list_count(vs, k, #n)
}

lemma list_count_append_true {
  statement:
    forall vs, k, n, v.
      list_count(vs, k, n) * (k == v) |- list_count(vs @ [v], k, n + 1)
}

lemma list_count_append_false {
  statement:
    forall vs, k, n, v.
      list_count(vs, k, n) * (k != v) |- list_count(vs @ [v], k, n)
}

lemma list_nth_next {
  statement:
    forall xs, ys, v, l, j.
    list_nth(xs @ [v, l] @ ys, j, v) |- list_nth(xs @ [v, l] @ ys, j + 1, l)
}


//#endregion
// === EDIT BELOW HERE ===

// 1. prepending a value to the front of the list (EASY)
//    (Note: this function verifies correctly in auto mode
//     without any tactics)
{ (v == #v) * (x == #x) * cc_sll(#v, #vs, #xs) }
function cc_slist_add_first(v, x) {
  node := new(2);
  [node] := x;
  size := [v];
  if (size == 0) {
    [v + 1] := node;
    [v + 2] := node
  } else {
    head := [v + 1];
    [node + 1] := head;
    [v + 1] := node
  };
  [v] := size + 1;
  return v
}
{ cc_sll(ret, #x::#vs, #nxs) }

// 2. appending a value to the element (EASY)
{ (v == #v) * cc_sll(#v, #vs, #xs) * (x == #x) }
function cc_slist_add_last(v, x) {
  node := new(2);
  [node] := x;
  size := [v];
  if (size == 0) {
    [v + 1] := node;
    [v + 2] := node
  } else {
    tail := [v + 2];
    [tail + 1] := node;
    [v + 2] := node
  };
  [v] := size + 1;
  return v
}
{ cc_sll(ret, #vs @ [ #x ], #nxs) }

// 3. getting the i-th node of linked list (HARD)
{ (v == #v) * (i == #i) * cc_sll(#v, #vs, #xs) * (0 <= #i) * (#i < (len #vs)) }
function get_node_at(v, i) {
  size := [v];
  if (i >= size) {
    r := null
  } else {
    head := [v + 1];
    prev := head;
    node := [head + 1];
    val := [head];
    j := 0;
    [[ invariant {bind: prev, node, val, j, #start, #end, #startp, #endp} 
        (i == #i) * (prev -b> val, node) * 
        lseg(head, prev, #start, #startp) * sll(node, #end, #endp) * 
        (#vs == #start @ [val] @ #end) * (#xs == #startp @ [prev] @ #endp) * 
        list_nth(#xs, j, prev) * list_nth(#vs, j, val) *
        ((j - 1) < i) ]];
    while (j < i) {
      assume (node != null);
      prev := node;
      val := [node];
      node := [node + 1];
      j := j + 1
    };
    r := new(3);
    [r] := val;
    [r + 1] := node;
    [r + 2] := prev;
  };
  return r
}
{ (ret -b> #val, #node, #prev) * cc_sll(#v, #vs, #xs) * list_nth(#xs, #i, #prev) * list_nth(#vs, #i, #val) }


// 4. counting the number of v's in a singly-linked list (MEDIUM)
{ (v == #v) * (k == #k) * cc_sll(#v, #vs, #xs) }
function cc_slist_contains(v, k) {
  head := [v + 1];
  node := head;
  count := 0;
  [[ invariant {bind: node, count, #start, #startp, #rg, #end, #endp} 
    lseg(head, node, #start, #startp) * sll(node, #end, #endp) * 
    (#vs == #start @ #end) * (#xs == #startp @ #endp) *
    list_count(#start, k, count) * list_count(#end, k, #rg) ]];
  while (node != null) {
    val := [node];
    if (val == k) {
      count := count + 1
    } else {
      skip
    };
    node := [node + 1];
  };
  
  return count
}
{ cc_sll(#v, #vs, #xs) * list_count(#vs, #k, ret) }